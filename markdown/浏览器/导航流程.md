# 导航流程：输入url到页面展示的过程

[参考资料](https://juejin.cn/post/6846687590540640263)

## 整理流程

![total](https://user-gold-cdn.xitu.io/2020/7/4/1731a0a7812b8fca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

从图中可以看出，存在进程间的通信（IPC）。

过程大致如下：

1. 浏览器进程发出url请求到网络进程
2. 网络进程发出请求，服务器返回HTTP数据，网络进程解析响应头数据，将其转发给浏览器进程
3. 浏览器收到网络进程的响应头数据后，发送CommitNavigation消息到渲染进程，发送CommitNavigation时会携带响应头信息
4. 渲染进程接收到CommitNavigation消息后，开始准备接受HTML数据，接受数据的方式是直接跟网络进程建立数据管道
5. 渲染进程会像浏览器进程“确认提交”，这是告诉浏览器进程，说我已经准备好接受和解析页面数据了
6. 最后浏览器进程更新页面状态

## 分析流程

* 用户输入url

    >浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的url；如果用户输入的内容符合url规则，会根据协议在这段内容上加上协议合成合法的url

* url请求

    浏览器构建请求行数据，并发送到网络进程

        GET / index.html HTTP1.1
  
* 网络进程获取到url，先去查找本地缓存，如果有，拦截请求，直接返回200，否则，进入网络请求过程

* 网络进程请求DNS返回域名对应的IP和端口号。如果之前有DNS缓存，就会直接返回缓存信息，否则，会发起请求解析。如果没有端口号，http默认80，https默认443。如果是https则还需要建立TLS连接

* 在进程TCP连接的过程中，Chrome有个同一域名最多建立6哥TCP连接的机制

* TCP三次握手建立连接，http请求加上TCP头部————包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输。

* 网络层在数据包上加上IP头部————包括源IP和目的IP地址，继续向下传输到底层

* 底层通过物理网络传输给目的服务器主机，紧接着目的服务器主机网络层接收到数据包，开始一层层向上传输。

* 应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态码301或者302，同时在请求头的Location字段中附上重定向的地址。如果不重定向，首先根据请求头中的If-None-Match的值来判断请求是否被更新，如果没有，返回304，否则，返回新数据+200，如果想要浏览器缓存数据，应该加入

        Cache-Control:Max-age=2000

* 数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度

        Connection:Keep-Alive

* 网络进程获取到数据包后进行解析，根据响应头中的Content-type来判断相应数据的类型。如果是字节流，将该请求交给下载管理器，如果是text/html类型，就通知浏览器进程获取文档准备渲染。

* 浏览器进程接到通知，根据当前页面b是否是从页面a打开并且和页面a是否同一站点（域名和协议一致），如果是，复用网页进程，否则，新创建一个单独的渲染进程。

* 浏览器会发出“提交文档”的消息给渲染进程，渲染进程接收到消息后，会和网络进程建立传输数据的管道，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程。

* 浏览器收到“确认提交”后，会更新浏览器的页面状态，包括了安全状态、地址栏url、前进后退的历史状态，并更新web页面，此时web页面是空白页。

* 渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来。